Activer l'environnement virtuel
se positionnner dans : 
/c/users/serjio/OCPython/cours_p5/oc_p5_openfoodfacts (develop)
puis lancer l'ordre: source env/scripts/activate

Installation de my sql connector 

pip install mysql-connector-python

Save all packages with freeze

pip freeze > requirements.txt

Soutenance

Thierry Chappuis — 05/20/2020
Petite info sur les soutenances dès le projet 5. Au projet 3, on apprend à écrire du code conforme et la tolérence descend au minimum par rapport au respect des PEP 8 et 257. On constate un gros relâchement à ce niveau au p5. Si flake8 retourne des erreurs, si les conventions de nommage de la PEP8 ne sont pas respectées, si on trouve des étoiles dans les imports ou que ces imports ne sont pas triés correctement, si le code n'est pas systématiquement documenté par des docstrings conformes à la PEP 257, si le code est procédural, si il n'y a pas de séparation entre la couche d'accès aux données et l'interface utilisateur (pas de requêtes SQL dans l'implémentation des menus), le projet part avec le status à retravailler avant même que la présentation n'ait lieu. Ce sont des métriques objectives relativement faciles à vérifier et à corriger (une grande partie peut être corrigée automatiquement). Ne vous inscrivez pas en soutenance avant. 
Par ailleurs, voici quelques recommandations plus générales. Créez des classes ciblées avec une seule responsabilité à chaque fois. Par exemple une classe ne devrait pas en même temps télécharger les produits depuis l'API, nettoyer et valider les données reçues, et enregistrer ces données en base. Ces responsabilités devrait faire l'objet de 3 classes séparées. Selon les principes SOLID, une classe ne doit avoir qu'une seule raison de changer. Pensez que vous devrez réutiliser ce code au projet 8, mais que vous ne pourrez pas le réutiliser en bloc tel quel. Avoir séparé les responsabilités sera d'un grand secours. Chaque table de la base de donnée devrait idéalement faire l'objet de une voir deux classes (voir webinaire).
Sur le plan de l'organisation générale du code, organisez-le en packages (au minimum un pour l'ensemble des modules de votre projet) selon le lien donné plus haut et en plusieurs module nommés selon le rôle joué par le contenu. Attention, pas de modules fourre-tout tels que foncrions.py ou classes.py.

Thierry Chappuis — 05/20/2020
Sur un plan algorithmique, implémenter le système de menus dans une boucle while monolithique composée de boucles while imbriquées est une construction fagile et peu flexible. Certains mentors la rejettent en soutenance et je réfléchis à faire de même. Une factorisation possible est de créer une classe avec une méthode par menu, puis d'utiliser une machine à états pour passer d'un menu à l'autre. Ce système est flexible, il permet des parcours utilisateur souples (retour au menu précédent, retour à l'accueil), permet de garder des méthodes courtes (au-delà d'un demi-écran, votre fonction est considée comme longue à factoriser si possible), et il est moins sujet à erreur qu'une boucle monolithique.

Finalement, sur le plan du sql, faites valider la structure de votre base de données, chassez les informations dupliquées, représenter les entités avec des relations plusieurs à un ou plusieurs à plusieurs dans des tables séparées (produit, catégorie, magasin, ...). Pour ceux qui n'utilisent pas d'ORM, attention au injections sql et renseignez-vous sur cette faille. Voir https://dev.mysql.com/doc/connector-python/en/connector-python-example-cursor-transaction.html(edited)

2


récupérer tes produits par paquets de 1000 par ordre de popularité depuis cgi/search.pl.
Il faut préciser un champ json=1

Thierry Chappuis — 05/20/2020
url = "https://fr.openfoodfacts.org/cgi/search.pl"

# requête de 1000 produits français classés par popularité
params = {
    "action": "process",
    "json": 1,
    "page_size": 1000, # ou 20, 50, 100, 250, 500
    "page": 1, # ou 2, 3, 4...
    "sort_by": "unique_scans_n", # popularité
}

# requête de 1000 produits français de la catégorie pizza classés par popularité
params = {
    "action": "process",
    "json": 1,
    "page_size": 1000, # ou 20, 50, 100, 250, 500
    "page": 1, # ou 2, 3, 4...
    "tagtype_0": "categories",
    "tag_contains_0": "contains"
    "tag_0": "pizza", # spécification de la catégorie
    "sort_by": "unique_scans_n", # popularité
}


Le paramètre s'utilises comme ça 
FIELDS = 'code,product_name_fr,nutriscore_grade,brands,ingredients_text_debug,quantity,categories'


Hello question posée sans 10.000 fois mais le comment est sélectionnée la liste des substituts proposés pour le produit X ? Juste par la /les catégories identiques ?
[11:47 PM]
Autre question, quelle est la taille de produit idéale ? Faut il rapatrier TOUTE la base produit ?

Thierry Chappuis — 05/25/2020
au moins un, idéalement quelques uns
[11:55 PM]
Une démarche qui fonctionne biens via les catégories et ou les pnns_groups 1 et 2.
[11:57 PM]
Une stratégie qui donne de bons résultats et qui donne une jolie requête: Sélectionner les produits ayant un meilleur nutriscore et qui ont des catégories en commun, ordonnés par nombre décroissant de catégories partagées. Ca peut se faire en une requête

OK, je n'ai pas une statistique aussi large. La plupart des étudiants se contente de 5-10k produits. A cette échelle, un download par catégorie ne fait probablement plus de sens. En downloadant les 15 premières pages de 1000 (15 reequêtes), tu as le même résultat avec un éventail tout aussi varié.

query = (
    "CREATE TABLE `Categories` ("
    "    `id` SMALLINT AUTO_INCREMENT, "
    f"    `subcategorie` VARCHAR({varchar_length}), "
    f"    `count` SMALLINT, `maincategorie` VARCHAR({varchar_length}), "
    "     PRIMARY KEY(`id`)"
    ");"
)

infos_db = {
          'host': 'Adresse_du_serveur_mysql',
          'user': 'Nom_utilisateur_Mysql',
          'password': 'Mot_De_Passe_Mysql',
          'database': 'nom_de_la_BDD'
          }
mysql.connector.connect(**infos_db)

exemple

a dépend tu peut te créer un fichier de config.py qui contiendra tes constantes sans utiliser de json...
exemple:
fichier config.py 
info_bdd = {
    'host': 'Adresse_du_serveur_mysql',
    'user': 'Nom_utilisateur_Mysql',
    'password': 'Mot_De_Passe_Mysql',
    'database': 'Nom_de_la_base_de_données'
    }


puis ton fichier de connexion
import config as constant
infobdd = constant.info_bdd.copy()
mysql.connector.connect(**infobdd)

Suite: Détail code SQL...

        self.mysql.cursor.execute("""
            SET NAMES utf8mb4;
        """)

        self.mysql.cursor.execute("""
            CREATE TABLE IF NOT EXISTS Category (
            id int(10) unsigned NOT NULL AUTO_INCREMENT,
            name varchar(150) NOT NULL,
            PRIMARY KEY (id),
            UNIQUE INDEX ind_uni_name (name)
            )
        ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
        """)

        self.mysql.cursor.execute("""
            CREATE TABLE IF NOT EXISTS SubstituedProduct (
            id int(10) unsigned NOT NULL AUTO_INCREMENT,
            name varchar(150) NOT NULL,
            nutriscore char(1) NULL,
            nutriscore_value int(1) NULL,
            url text NOT NULL,
            stores text NOT NULL,
            category_id int(10) unsigned NOT NULL,
            category_name varchar(150) NOT NULL, 
            PRIMARY KEY (id)
        )
        ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

        """)

        self.mysql.cursor.execute("""
            CREATE TABLE IF NOT EXISTS Product (
            id int(10) unsigned NOT NULL AUTO_INCREMENT,
            name varchar(150) NOT NULL,
            nutriscore char(1) NULL,
            nutriscore_value int(1) NULL,
            url text NOT NULL,
            stores text NOT NULL,
            substitut_id int(10) unsigned NOT NULL DEFAULT '0',
            category_id int(10) unsigned NOT NULL,
            category_name varchar(150) NOT NULL,
            PRIMARY KEY (id),
            UNIQUE INDEX ind_uni_substitut_id (substitut_id),
            CONSTRAINT fk_substitut_id FOREIGN KEY (substitut_id) REFERENCES SubstituedProduct(id),
            CONSTRAINT fk_category_id FOREIGN KEY (category_id) REFERENCES Category(id),
            CONSTRAINT fk_category_name FOREIGN KEY (category_name) REFERENCES Category(name)
        )
        ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
        """)

Thierry Chappuis — 04/21/2020
Pour le charset, précise-le une fois pour toute au niveau de la base. Pour l'engine, c'est de toute manière InnoDB par défaut.
[11:49 AM]
Pour les foreign key, elles ne doivent pointer que sur la primary key de la table étrangère. Donc, ici, n'ajoute qu'une seule clé dans product, pas deux
[11:50 AM]
L'usage d'une foreign key a également l'effet que tu ne pourras enregistrer que une seule catégorie par produit. Par ailleurs, les stores devraient également être enregistrés dans une table séparées et liés aux produits par une table d'association.
[11:52 AM]
Je ne vois pas le besoin d'avoir une table Product et une table SubstitutedProduct avec de l'information dupliquée. Utilise une seule table product avec une relation plusieurs à plusieurs sur elle-même.

query = "INSERT INTO categories(category_name) VALUES (%(name)s)"
cursor.execute(query, dico)

Leto — 01/21/2021
je n'ai pas de dico
[3:03 PM]
name est un paramètre qui sera passé dans une boucle
[3:03 PM]
serait-ce un problème ?

Thierry Chappuis — 01/21/2021
dans ce cas:
query = "INSERT INTO categories(category_name) VALUES (%(name)s)"
cursor.execute(query, {"name": variable_avec_nom})
connection.commit()